
TLORMEngine.GameConfig = {};

TLORMEngine.GameConfig.validate = function(game_config) {
	var result = tv4.validate(game_config, TLORMEngine.GameConfig.schema());
	TLORMEngine.Utils.error(tv4.missing);
	if (!result) {
		TLORMEngine.Utils.error(tv4.error, true);
		return false;
	}

	return result;
};

TLORMEngine.GameConfig.schema = function() {
	var schema = this.base_schema();

	// lookup all systems
	for (var system_type in TLORMEngine.Systems) {
		if (system_type == "System") {
			continue;
		}
		schema.properties.systems.items.enum.push(system_type);
	}

	// lookup all screens
	for (var screen_type in TLORMEngine.Screens) {
		schema.properties.screens.items.type.push({
			type: "object",
			properties: {
				type: {
					title: "Screen Type",
					enum: [ screen_type ],
					required: true
				},
				name: {
					title: "Screen Name (should be unique)",
					type: "string",
					required: true
				},
				current_screen: {
					title: "Starting Screen?",
					description: "Flag to indicate which screen to start on",
					type: "boolean"
				},
				args: {
					title: "Screen Arguments",
					description: "Arguments to pass on to the Screen",
					type: "object",
					properties: TLORMEngine.Screens[screen_type].prototype.args_schema()
				}
			}
		});
	}

	// lookup all components
	var any_component_schemas = [];
	var any_component_type_refs = [];
	for (var component_type in TLORMEngine.Components) {
		if (component_type == "Component") {
			continue;
		}
		var component_schema = {
			type: "object",
			id: "#"+component_type+"Component",
			properties: {
				type: {
					title: "Component Type",
					enum: [ component_type ],
					required: true
				},
				args: {
					title: "Component Arguments",
					description: "Arguments to pass on to the Component",
					type: "object",
					properties: TLORMEngine.Components[component_type].prototype.args_schema()
				}
			}
		};
		schema.properties.entities.items.properties.components.items.type.push(component_schema);
		any_component_type_refs.push({ "$ref": component_type+"Component" });

		// check if we need to add more to this
		for (var key in component_schema.properties.args.properties) {
			if (component_schema.properties.args.properties[key].type && component_schema.properties.args.properties[key].type == "TLORM_ANY_COMPONENT") {
				any_component_schemas.push(component_schema.properties.args.properties[key]);
			}
		}
	}

	// add the any component schemes
	for (var i=0; i<any_component_schemas.length; ++i) {
		any_component_schemas[i].type = any_component_type_refs;
	}


	return schema;
};

TLORMEngine.GameConfig.base_schema = function() {
	return {
		"$schema": "http://json-schema.org/draft-04/schema#",
		title: "TLORM Game Config",
		description: "Configuration of a Game to be generated by TLORM Engine",
		type: "object",
		properties: {
			name: {
				title: "Name of Game",
				type: "string",
				required: true
			},
			width: {
				title: "Width of Game (in pixels)",
				type: "integer",
				required: true
			},
			height: {
				title: "Height of Game (in pixels)",
				type: "integer",
				required: true
			},
			systems: {
				title: "Systems to use in the Game",
				type: "array",
				items: {
					title: "System Type",
					enum: []
				}
			},
			screens: {
				title: "Screens to show in the Game",
				type: "array",
				required: true,
				minItems: 1,
				items: { type: [] }
			},
			entities: {
				title: "Entities to use in the Game",
				type: "array",
				required: true,
				minItems: 1,
				items: {
					type: "object",
					properties: {
						name: {
							title: "Entity Name (should be unique)",
							type: "string",
							required: true,
						},
						components: {
							title: "Components within this Entity",
							type: "array",
							required: true,
							minItems: 1,
							items: { type: [] }
						}
					}
				}
			}
		}
	};
};